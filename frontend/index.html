<!doctype html>
<html lang="pt-BR" class="dark">
  <head>
    <meta charset="UTF-8" />
    <script>
      // ============================================
      // INTERCEPTAÇÃO ULTRA-AGRESSIVA DO MEDIASESSION
      // ============================================
      // Este código DEVE executar ANTES de qualquer extensão do navegador
      // (como autoPip.js) tentar usar o MediaSession API
      
      // Polyfills básicos para compatibilidade (sem require que quebra o app)
      window.global = window;
      window.module = { exports: {} };
      window.exports = window.module.exports;
      window.process = { env: {} };
      
      // Lista de ações suportadas oficialmente pelo MediaSession API
      const SUPPORTED_MEDIA_SESSION_ACTIONS = [
        'play', 'pause', 'seekbackward', 'seekforward', 
        'previoustrack', 'nexttrack', 'seekto', 'stop'
      ];
      
      // Função segura para registrar ações de mídia
      // Esta função BLOQUEIA ações não suportadas ANTES de tentar registrá-las
      const safeSetActionHandler = (action, handler) => {
        // Verificar se a ação é suportada ANTES de tentar qualquer coisa
        if (!SUPPORTED_MEDIA_SESSION_ACTIONS.includes(action)) {
          // Silenciosamente ignora ações não suportadas (como enterpictureinpicture)
          return undefined;
        }
        
        try {
          if ('mediaSession' in navigator && 'setActionHandler' in navigator.mediaSession) {
            return navigator.mediaSession.setActionHandler(action, handler);
          }
        } catch (error) {
          // Ignora silenciosamente erros
          return undefined;
        }
        return undefined;
      };
      
      // ESTRATÉGIA 1: Interceptar navigator.mediaSession usando Proxy
      // Isso captura QUALQUER acesso ao mediaSession, mesmo antes de ser criado
      if (typeof navigator !== 'undefined') {
        try {
          // Salvar o mediaSession original se existir
          const originalMediaSession = navigator.mediaSession;
          
          // Criar um Proxy para interceptar acesso ao mediaSession
          let mediaSessionProxy = null;
          
          // Interceptar na propriedade navigator.mediaSession
          Object.defineProperty(navigator, 'mediaSession', {
            get: function() {
              const actualMediaSession = originalMediaSession || this._mediaSession;
              
              if (!actualMediaSession) {
                return undefined;
              }
              
              // Se ainda não criamos o proxy, criar agora
              if (!mediaSessionProxy && actualMediaSession) {
                // Criar proxy que intercepta setActionHandler
                mediaSessionProxy = new Proxy(actualMediaSession, {
                  get: function(target, prop) {
                    if (prop === 'setActionHandler') {
                      // Retornar versão segura do setActionHandler
                      return function(action, handler) {
                        return safeSetActionHandler(action, handler);
                      };
                    }
                    return target[prop];
                  },
                  set: function(target, prop, value) {
                    if (prop === 'setActionHandler') {
                      // Bloquear substituição direta
                      return true;
                    }
                    target[prop] = value;
                    return true;
                  }
                });
              }
              
              return mediaSessionProxy || actualMediaSession;
            },
            set: function(value) {
              this._mediaSession = value;
              // Aplicar wrapper imediatamente quando mediaSession for definido
              if (value && 'setActionHandler' in value) {
                const original = value.setActionHandler.bind(value);
                try {
                  Object.defineProperty(value, 'setActionHandler', {
                    value: function(action, handler) {
                      return safeSetActionHandler(action, handler);
                    },
                    writable: false,
                    configurable: false
                  });
                } catch (e) {
                  // Fallback: substituição direta
                  value.setActionHandler = function(action, handler) {
                    return safeSetActionHandler(action, handler);
                  };
                }
              }
            },
            configurable: true,
            enumerable: true
          });
        } catch (e) {
          // Se Proxy falhar, usar fallback
        }
      }
      
      // ESTRATÉGIA 2: Wrapper direto no setActionHandler
      const wrapMediaSession = () => {
        if ('mediaSession' in navigator && navigator.mediaSession) {
          try {
            if ('setActionHandler' in navigator.mediaSession) {
              const original = navigator.mediaSession.setActionHandler.bind(navigator.mediaSession);
              try {
                Object.defineProperty(navigator.mediaSession, 'setActionHandler', {
                  value: function(action, handler) {
                    return safeSetActionHandler(action, handler);
                  },
                  writable: false,
                  configurable: false
                });
              } catch (e) {
                // Fallback: substituição direta
                navigator.mediaSession.setActionHandler = function(action, handler) {
                  return safeSetActionHandler(action, handler);
                };
              }
            }
          } catch (e) {
            // Ignorar se não conseguir
          }
        }
      };
      
      // Aplicar wrapper imediatamente e repetidamente
      wrapMediaSession();
      setTimeout(wrapMediaSession, 0);
      setTimeout(wrapMediaSession, 1);
      setTimeout(wrapMediaSession, 5);
      setTimeout(wrapMediaSession, 10);
      setTimeout(wrapMediaSession, 50);
      setTimeout(wrapMediaSession, 100);
      
      // Handler global para capturar erros não tratados (incluindo autoPip.js de extensões)
      // IMPORTANTE: Usar capture phase e ser o primeiro handler
      window.addEventListener('error', function(event) {
        // Captura erros de extensões do navegador (chrome-extension://, moz-extension://, etc.)
        const isExtensionError = event.filename && (
          event.filename.includes('chrome-extension://') ||
          event.filename.includes('moz-extension://') ||
          event.filename.includes('safari-extension://') ||
          event.filename.includes('autoPip.js') ||
          event.filename.includes('auto-pip') ||
          event.filename.includes('content.ts') ||
          event.filename.includes('snippets.js') ||
          event.filename.includes('extension://')
        );
        
        // Captura erros de MediaSession e autoPip.js (pode vir de extensões do navegador)
        const isMediaSessionError = event.message && (
          event.message.includes('setActionHandler') ||
          event.message.includes('enterpictureinpicture') ||
          event.message.includes('MediaSessionAction') ||
          event.message.includes('MediaSession')
        );
        
        // Captura erros de fetch de extensões
        const isExtensionFetchError = event.message && (
          event.message.includes('Failed to fetch dynamically imported module') ||
          event.message.includes('Failed to fetch') ||
          (event.filename && (
            event.filename.includes('chrome-extension://') ||
            event.filename.includes('content.ts') ||
            event.filename.includes('snippets.js')
          ))
        );
        
        // Captura erros de "message channel closed" (extensões do navegador)
        const isMessageChannelError = event.message && (
          event.message.includes('message channel closed') ||
          event.message.includes('listener indicated an asynchronous response')
        );
        
        if (isExtensionError || isMediaSessionError || isExtensionFetchError || isMessageChannelError) {
          event.preventDefault();
          event.stopPropagation();
          event.stopImmediatePropagation();
          // Não logar para evitar poluição do console
          return false;
        }
        
        // Capturar erros de inicialização do Supabase (problema de ordem de carregamento)
        // NOTA: Este erro geralmente se resolve sozinho, então vamos apenas silenciar
        if (event.message && (
          event.message.includes('Cannot access') && 
          event.message.includes('before initialization') &&
          (event.filename && event.filename.includes('supabase'))
        )) {
          // Este erro pode ser causado por ordem de carregamento ou minificação
          // Geralmente se resolve sozinho, então vamos apenas silenciar
          event.preventDefault();
          event.stopPropagation();
          event.stopImmediatePropagation();
          // Não logar para evitar poluição do console
          return false;
        }
      }, true);
      
      // Handler para Promise rejections não tratadas
      // Intercepta rejeições de Promises relacionadas ao MediaSession
      window.addEventListener('unhandledrejection', function(event) {
        const reason = event.reason;
        const reasonMessage = reason?.message || String(reason || '');
        const reasonStack = reason?.stack || '';
        
        // Captura erros de extensões do navegador
        const isExtensionError = reasonStack && (
          reasonStack.includes('chrome-extension://') ||
          reasonStack.includes('moz-extension://') ||
          reasonStack.includes('safari-extension://') ||
          reasonStack.includes('autoPip.js') ||
          reasonStack.includes('auto-pip') ||
          reasonStack.includes('content.ts') ||
          reasonStack.includes('snippets.js')
        );
        
        // Captura erros de MediaSession
        // Verificar tanto a mensagem quanto o stack para garantir interceptação completa
        const isMediaSessionError = (
          (reasonMessage && (
            reasonMessage.includes('setActionHandler') ||
            reasonMessage.includes('enterpictureinpicture') ||
            reasonMessage.includes('exitpictureinpicture') ||
            reasonMessage.includes('MediaSessionAction') ||
            reasonMessage.includes('MediaSession') ||
            reasonMessage.includes('not a valid enum value')
          )) ||
          (reasonStack && (
            reasonStack.includes('autoPip') ||
            reasonStack.includes('auto-pip')
          ))
        );
        
        // Captura erros de fetch de extensões
        const isExtensionFetchError = reasonMessage && (
          reasonMessage.includes('Failed to fetch dynamically imported module') ||
          reasonMessage.includes('Failed to fetch') ||
          reasonStack.includes('chrome-extension://') ||
          reasonStack.includes('content.ts') ||
          reasonStack.includes('snippets.js')
        );
        
        // Captura erros de "message channel closed" (extensões do navegador)
        const isMessageChannelError = reasonMessage && (
          reasonMessage.includes('message channel closed') ||
          reasonMessage.includes('listener indicated an asynchronous response')
        );
        
        if (isExtensionError || isMediaSessionError || isExtensionFetchError || isMessageChannelError) {
          event.preventDefault();
          event.stopPropagation();
          // Não logar para evitar poluição do console
          return;
        }
        
        // Capturar Promise rejections do Supabase
        // NOTA: Este erro geralmente se resolve sozinho, então vamos apenas silenciar
        if (reasonMessage && (
          reasonMessage.includes('Cannot access') && 
          reasonMessage.includes('before initialization')
        )) {
          event.preventDefault();
          event.stopPropagation();
          // Não logar para evitar poluição do console
          return;
        }
      });
    </script>
    <link rel="icon" type="image/png" sizes="192x192" href="/icon-192.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <!-- SEO Meta Tags -->
    <title>Let's Roll - Plataforma de RPG de Mesa Online</title>
    <meta name="description" content="Plataforma completa para jogar RPG de mesa online. Sistema Ordem Paranormal, fichas de personagem, dados virtuais e muito mais." />
    <meta name="keywords" content="RPG, RPG de mesa, Ordem Paranormal, D&D, dados virtuais, campanha RPG" />
    <meta name="author" content="Let's Roll Team" />
    <meta name="theme-color" content="#8000FF" />
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Let's Roll - Plataforma de RPG de Mesa Online" />
    <meta property="og:description" content="Plataforma completa para jogar RPG de mesa online. Sistema Ordem Paranormal, fichas de personagem, dados virtuais e muito mais." />
    <meta property="og:site_name" content="Let's Roll" />
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Let's Roll - Plataforma de RPG de Mesa Online" />
    <meta name="twitter:description" content="Plataforma completa para jogar RPG de mesa online. Sistema Ordem Paranormal, fichas de personagem, dados virtuais e muito mais." />
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json" />
    
    <!-- PWA Icons -->
    <link rel="icon" type="image/png" sizes="192x192" href="/icon-192.png" />
    <link rel="icon" type="image/png" sizes="512x512" href="/icon-512.png" />
    <link rel="apple-touch-icon" href="/icon-192.png" />
    
    <!-- PWA Meta Tags -->
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="Let's Roll" />
    
    <!-- Content Security Policy -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://www.googletagmanager.com https://www.google-analytics.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: https: blob:; font-src 'self' data:; connect-src 'self' https://*.supabase.co https://www.google-analytics.com wss://*.supabase.co; frame-src 'self'; object-src 'none'; base-uri 'self'; form-action 'self';" />
  </head>
  <body>
    <div id="root"></div>
    <!-- Carregar error-handler ANTES de qualquer outro script -->
    <script src="/error-handler.js"></script>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


